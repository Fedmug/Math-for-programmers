# Зачем математика программистам?

На заре компьютерной эры, когда профессии «программист» ещё не существовало, приходилось черпать кадры из таких областей науки, как математика и физика. Например, из математики родом
* пионеры информатики Алан Тьюринг и Джон фон Нейман;
* автор монументального труда «Искусство программирования» Дональд Кнут;
* создатель одного из самых популярных ныне языков программирования — Python — Гвидо ван Россум.

Не секрет, что и сейчас выпускники физико-математических специальностей широко востребованы в IT-сфере. Есть даже расхожая фраза:
> Из хорошего математика получится хороший программист, наоборот — никогда!

Чем же так богата математическая почва, позволяющая добиться столь впечатляющих всходов на ниве программирования и компьютерных наук? На самом деле особых секретов тут нет. За века и тысячелетия математики напридумывали достаточно всякого-разного инструментария на все случаи жизни, покрывающего в том числе и нужды программирования. Перечислим несколько простых и при этом чрезвычайно полезных в программировании математических конструкций.

### Позиционная система счисления

В повседневной жизни мы пользуется арабскими цифрами, записывая числа и дроби в десятичной системе счисления. Это позволяет достаточно компактно и безболезненно записывать очень большие числа. Сомневаетесь? Попробуйте записать не самое гигантское число $123456789$ римскими цифрами, и ощутите всю прелесть нашей позиционной системы.

В привычной нам десятичной системе счисления удобно выводить результаты компьютерных вычислений, однако, внутри компьютеры оперируют двоичным кодом. Поэтому полезно уметь переводить числа из десятичной системы в двоичную и обратно. Двоичной же системой продиктованы соотношения между единицами информации: бит (содержит $0$ или $1$), байт ( $8$ бит), килобайт ($2^10 = 1024$ байт) и т.д.

### Координаты

Точки, прямые, треугольники, прямоугольники, круги и прочие обитатели евклидовой геометрии часто используются при работе с графикой, но
практическая работа с ними на компьютере возможна благодаря революционному открытию Декарта — аналитической геометрии. Теперь каждая точка на плоскости может быть задана (декартовыми) координатами — парой чисел, и это исключительно удобно при построении разного рода графиков или при обработке изображений. Если у вас есть картинка размера $W\times H$, то выбирая за точку отсчёта, например, её нижний левый угол, доступ к каждому пикселю можно получить по координатам $(w, h)$, $0\leqslant w < W$, $0 \leqslant h < H$. А у цветных изображений имеется ещё и третья координата, отвечающая за канал (к примеру, RGB), и тогда пиксель задаётся тройкой чисел $(w, h, c)$.

### Алгебра логики

Практически любой язык программирования имеет в своём арсенале управляющие конструкции `if/else`, позволяющие выбирать дальнейший ход исполнения
программы в зависимости от логического выражения. [Логика высказываний](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B8), называемая также *булевой алгеброй* по имени основоположника Джорджа Буля, предоставляет математический фреймворк для работы такими выражениями. Любое высказывание в рамках формальной логики может иметь два значения: «истина» или «ложь», обозначаемы также через $1$ и $0$. Логические операции `and` (конъюнкция), `or` (дизъюнкция), `not` (отрицание), `xor` (исключающее ИЛИ) позволяют строить новые высказывания из уже имеющихся. Для определения значения вновь построенного высказывания применяют *таблицы истинности*:

| `A`    | `B`     | `A and B` | `A or B` | `not A` | `A xor B` |
|--------| ------- | --------- | -------- | ------- | --------- |
| $0$    | $0$     | $0$       | $0$      | $1$     | $0$       |
| $0$    | $1$     | $0$       | $1$      | $1$     | $1$       |
| $1$    | $0$     | $0$       | $1$      | $0$     | $1$       |
| $1$    | $1$     | $1$       | $1$      | $0$     | $0$       |

### О-символика

Время работы алгоритма удобно представлять себе как функцию от размера входных данных. Классический пример: сортировка массива из $n$ элементов выполняется за время, пропорциональное числу попарных сравнений. Это число существенно разнится в зависимости от алгоритма и входных данных, например:
* [сортировка слиянием](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC) требует от $0.8n\log n$ до $1.5n\log n$ сравнений;
* [сортировка пузырьком](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC) требует ровно $\frac{n^2-n}2$ сравнений;
* [сортировка вставкой](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0%D0%BC%D0%B8) требует не более $\frac{n^2-n}2$ сравнений;
* метод грубой силы, перебирающий все $n!$ перестановок массива и проверяющий, отсортирован ли очередной вариант, может затратить вплоть до $n\cdot n!$ сравнений.

Для анализа алгоритма практически несущественно, работает он за $n^2-n$ или за $n^2$; да и разница между $n^2$ и $\frac 12 n^2$ не так уж важна. Все эти величины можно записать как $O(n^2)$ в ознаменование того, что они не превосходят $Cn^2$ при некотором $C > 0$. О-символика широко используется для сравнения скорости работы алгоритмов. Так, сортировка слиянием работает за $O(n \log n)$ сравнений, сортировка вставкой или пузырьком — за $O(n^2)$, а метод грубой силы — за $O(n\cdot n!)$. Поскольку $\log n \ll n \ll n!$ при больших $n$, эффективнее всего метод сортировки слиянием, а вот brute force никуда не годится из-за чрезвычайно быстрой скорости роста факториала.

## Вместо заключения

Математические понятия произрастают из опыта взаимодействия с реальным миром и представляют собой кристаллизованные абстракции, очищенные от лишних подробностей. [Непостижимая эффективность математики](http://ogs-seminar.narod.ru/materials/effectiveness_of_mathematics.pdf) что в естественных, что в компьютерных науках зиждется на универсальности этих абстракций, которые с лёгкостью адаптируются к прикладным ситуациям.
