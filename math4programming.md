# Зачем математика программистам?

На заре компьютерной эры, когда профессии «программист» ещё не существовало, приходилось черпать кадры из таких областей науки, как математика и физика. Например, из математики родом
* пионеры информатики Алан Тьюринг и Джон фон Нейман;
* автор монументального труда «Искусство программирования» Дональд Кнут;
* создатель одного из самых популярных ныне языков программирования — Python — Гвидо ван Россум.

Не секрет, что и сейчас выпускники физико-математических специальностей широко востребованы в IT-сфере. Есть даже расхожая фраза:
> Из хорошего математика получится хороший программист, наоборот — никогда!

Чем же так богата математическая почва, позволяющая добиться столь впечатляющих всходов на ниве программирования и компьютерных наук? На самом деле особых секретов тут нет. За века и тысячелетия математики напридумывали достаточно всякого-разного инструментария на все случаи жизни, покрывающего в том числе и нужды программирования. Перечислим несколько простых и при этом чрезвычайно полезных в программировании математических конструкций.

### Позиционная система счисления

По техническим причинам компьютерам удобно производить вычисления в [двоичной системе счисления](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F). Запись числа в такой системе счисления называют также *двоичным кодом*. Принцип такой записи отличается от привычной нам десятичной системы лишь меньшим количеством использумых цифр: двоичный код состоит только из нулей и единиц. Помимо двоичной в информатике часто используется [шестнадцатеричная система счисления](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D0%B4%D1%86%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F), а иногда ещё и *восьмеричная*. Все они относятся к семейству [позиционных систем счисления](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F), у которых значение цифры зависит от позиции (разряда). Например,

$$
  1984 = 1\cdot 10^3 + 9\cdot 10^2 + 8\cdot 10^1 + 4;
$$

с другой стороны,

$$
1984 = 1024 + 512 + 256 + 128 + 64 = 2^{10} +2^9 + 2^8+2^7+2^6,
$$

и поэтому $1984_{10} = 11111000000_2$. Аналогично

$$
1984 = 7\cdot 256 + 12\cdot 16 = 7\cdot 16^2 + 12 \cdot 16^1,
$$

откуда следует, что $1984_{10} = 7\mathrm c0_{16}$ (шестнадатеричная система требует $16$ цифр, поэтому к стандартным цифрам $0-9$ добавляются «цифры» $a=10$, $b=11$, $c=12$, $d=13$, $e=14$, $f=15$). Наконец, для восьмеричной системы получаем

$$
  1984_{10} = 3\cdot 512 + 7\cdot 64 = 3\cdot 8^3 + 7 \cdot 8^2 = 3700_8.
$$

Позаимствованные в Индии арабские цифры вошли в обиход сравнительно недавно по историческим меркам, в эпоху Средневековья. Широко используемые до этого римские цифры позволяют эффективно записывать весьма ограниченный диапазон чисел. Для числа $1984$ римская запись MCMLXXXIV выглядит ещё не слишком жутко, но попробуйте записать римскими цифрами, например, не самое гигантское число $123456789$ римскими цифрами, и ощутите всю прелесть нашей позиционной системы счисления. Именно благодаря ей компьютеры могут легко ворочать миллионами и миллиардами, а также выводить результаты вычислений в обозримом виде.

### Координаты

Точки, прямые, треугольники, прямоугольники, круги и прочие обитатели евклидовой геометрии часто используются при работе с графикой, но
практическая работа с ними на компьютере возможна благодаря революционному открытию Декарта — аналитической геометрии. В ней каждая точка на плоскости может быть задана *(декартовыми) координатами* — парой чисел, и это исключительно удобно при построении разного рода графиков или при обработке изображений. Например, если у вас есть картинка размера $W\times H$, то выбирая за точку отсчёта любой из её углов, доступ к каждому пикселю можно получить по координатам $(w, h)$, $0\leqslant w < W$, $0 \leqslant h < H$. А у цветных изображений имеется ещё и третья координата, отвечающая за канал (к примеру, RGB), и тогда пиксель задаётся тройкой чисел $(w, h, c)$.

### Алгебра логики

Практически любой язык программирования имеет в своём арсенале управляющие конструкции `if/else`, позволяющие выбирать дальнейший ход исполнения
программы в зависимости от значения логического выражения. [Логика высказываний](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B8), называемая также *булевой алгеброй* по имени основоположника Джорджа Буля, предоставляет математический фреймворк для работы такими выражениями. Любое высказывание в рамках формальной логики может иметь два значения: «истина» или «ложь», обозначаемые также через $1$ и $0$. Логические операции `and` (конъюнкция), `or` (дизъюнкция), `not` (отрицание), `xor` (исключающее ИЛИ) позволяют строить новые высказывания из уже имеющихся. Для определения значения вновь построенного высказывания применяют *таблицы истинности*:

| `A`    | `B`     | `A and B` | `A or B` | `not A` | `A xor B` |
|--------| ------- | --------- | -------- | ------- | --------- |
| $0$    | $0$     | $0$       | $0$      | $1$     | $0$       |
| $0$    | $1$     | $0$       | $1$      | $1$     | $1$       |
| $1$    | $0$     | $0$       | $1$      | $0$     | $1$       |
| $1$    | $1$     | $1$       | $1$      | $0$     | $0$       |

### О-символика

Время работы алгоритма удобно представлять себе как функцию от размера входных данных. Классический пример: сортировка массива из $n$ элементов выполняется за время, пропорциональное числу попарных сравнений. Это число существенно разнится в зависимости от алгоритма и входных данных, например:
* [сортировка слиянием](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC) требует от $0.8n\log n$ до $1.5n\log n$ сравнений;
* [сортировка пузырьком](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC) осуществляет ровно $\frac{n^2-n}2$ сравнений;
* [сортировка вставкой](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0%D0%BC%D0%B8) производит от $n$ до $\frac{n^2-n}2$ сравнений;
* метод грубой силы, перебирающий все $n!$ перестановок массива и проверяющий, отсортирован ли очередной вариант, может затратить вплоть до $n\cdot n!$ сравнений.

Для анализа алгоритма практически несущественно, работает он за $n^2-n$ или за $n^2$; да и разница между $n^2$ и $\frac 12 n^2$ не так уж важна. Все эти величины можно записать как $O(n^2)$ в ознаменование того, что они не превосходят $Cn^2$ при некотором $C > 0$. О-символика широко используется для сравнения скорости работы алгоритмов. Так, сортировка слиянием работает за $O(n \log n)$ сравнений, сортировка вставкой или пузырьком — за $O(n^2)$, а метод грубой силы — за $O(n\cdot n!)$. Поскольку $\log n \ll n \ll n!$ при больших $n$, эффективнее всего метод сортировки слиянием, а вот brute force никуда не годится из-за чрезвычайно быстрой скорости роста факториала.

Следует отметить, что оценки с помощью О-большого носят асимптотический характер и гарантированно работают лишь при больших значениях $n$.
Например, для небольших массивов алгоритм сортировки вставкой предпочтительнее сортировки слиянием, поскольку он проще в реализации и, как правило, требует меньшего числа сравнений при $n < 10$, невзирая на то, что $n^2 > n\log n$.

## Вместо заключения

Разумеется, полезные для программиста разделы математики не ограничиваются описанными выше примерами. Например, чтобы влиться в модный нынче Data Science, весьма нелишне будет подтянуть знания по избранным темам теории вероятностей, математической статистики, линейной алгберы, математического анализа. Можно ли обойтись без всей этой премудрости? Ну это примерно как водить машину без всякого представления о том, что находится под капотом. Навыков вращать руль и нажимать на педали какое-то время будет хватать, но лишь до первой поломки или иной нештатной ситуации. На этот случай есть автомеханики и прочие специально обученные люди? Так же и у работодателя найдутся более достойные кандидаты, которые кроме fit-predict умеют кое-что ещё.

Помимо прикладного значения различных математических концепций следует отметить и несомненную выгоду для программирования от математического подхода в целом. Часто это называют «математическим мышлением», которое проявляется, в частности, в следующем:
* особое внимание к крайним случаям;
* абстрагирование в целях борьбы со сложностью;
* игнорирование несущественных деталей без ущерба для происходящего.
